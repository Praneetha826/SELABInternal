# Q1 — Jenkins Pipeline (Java or Web project) — end-to-end (25 marks)

Goal: **automate build → test → package → deploy** via Jenkins pipelines; produce console output, artifacts, and pipeline view.

## What to prepare BEFORE exam

* Jenkins server accessible (e.g. `http://localhost:8080`).
* Jenkins plugins: Git, Pipeline, Credentials, Email (Mailer or Email Extension), Deploy (if using Tomcat), Blue Ocean (optional).
* A Git repo with the project (Java Maven or Webapp with pom/war).
* Tomcat (for web project) or Docker for container deployment (optional).

---

## A. Jenkinsfile — Declarative pipeline (copy/paste & adapt)

**For a Maven Java project**

```groovy
pipeline {
  agent any
  environment {
    MVN = "mvn"
  }
  stages {
    stage('Checkout') {
      steps { git url: 'https://github.com/USER/REPO.git', branch: 'main' }
    }
    stage('Build') {
      steps { sh "${MVN} -B -DskipTests clean package" }
    }
    stage('Unit Test') {
      steps {
        sh "${MVN} -B test"
        junit '**/target/surefire-reports/*.xml'
      }
    }
    stage('Archive') {
      steps { archiveArtifacts artifacts: 'target/*.jar', fingerprint: true }
    }
    stage('Deploy (optional)') {
      when { expression { env.DEPLOY == 'true' } }
      steps {
        // Example: push to Tomcat manager or docker
        echo "Deploy step — implement per environment"
      }
    }
  }
  post {
    success { echo "BUILD SUCCESS (Jenkinsfile)" }
    failure { echo "BUILD FAILED" }
  }
}
```

**For a Web (WAR) with Tomcat deploy (using curl to manager):**

```groovy
stage('Deploy to Tomcat') {
  steps {
    withCredentials([usernamePassword(credentialsId: 'tomcat-creds', usernameVariable: 'TUSER', passwordVariable: 'TPASS')]) {
      sh '''
        WAR=$(ls target/*.war | head -n1)
        curl --upload-file $WAR "http://$TUSER:$TPASS@tomcat-host:8080/manager/text/deploy?path=/myapp&update=true"
      '''
    }
  }
}
```

---

## B. Create job & pipeline view

1. **New Item → Pipeline**, point to repo with Jenkinsfile (or paste script).
2. Run **Build Now** — open **Console Output** to capture `BUILD SUCCESS`.
3. Install **Blue Ocean** or use **Stage View** to capture pipeline visualization.
4. Save artifacts screenshot + pipeline view screenshot.

**Evidence to collect:** Jenkinsfile (text), console output (showing `BUILD SUCCESS`), archived artifact link, pipeline view screenshot.

---

## C. Common pitfalls & fixes

* **mvn not found** → use Docker agent (e.g. `agent { docker 'maven:3.8.8-jdk11' }`) or set Maven path on agent.
* **Git clone auth fails** → add credentials in Jenkins → Credentials → use id in checkout.
* **Permission/port issues for Tomcat** → check tomcat-users.xml roles (`manager-script`), manager URL `/manager/text`.
* **Build times out** → increase job timeout or allocate more resources.

---

# Q2 — Minikube: Nginx deployment & expose on port (25 marks)

Goal: start local k8s, deploy nginx, expose it and verify via browser; list pods/services.

> Note: Kubernetes NodePort range is **30000–32767**. You cannot use 8090 as a NodePort unless you change the API server config.

## Steps & commands (Windows / macOS / Linux)

1. **Start minikube (docker driver preferred)**

```bash
minikube start --driver=docker
```

Expected: `Done! kubectl is now configured to use "minikube"`

2. **Create deployment**

```bash
kubectl create deployment nginx-deploy --image=nginx
```

Expected: `deployment.apps/nginx-deploy created`

3. **Expose deployment as NodePort (k8s chooses an available nodePort in 30000-32767)**

```bash
kubectl expose deployment nginx-deploy --type=NodePort --port=80 --name=nginx-service
```

Expected: `service/nginx-service exposed`

4. **Get assigned URL (minikube maps nodePort to localhost)**

```bash
minikube service nginx-service --url
```

Output: e.g. `http://127.0.0.1:53517` — use this to open in browser

5. **List pods and services**

```bash
kubectl get pods -o wide
kubectl get svc -o wide
```

Expected sample:

```
NAME                             READY   STATUS    RESTARTS   AGE
nginx-deploy-xxxxx-abcde         1/1     Running   0          2m

NAME            TYPE       CLUSTER-IP     EXTERNAL-IP  PORT(S)        AGE
nginx-service   NodePort   10.108.12.34   <none>       80:53517/TCP   2m
```

6. **Open in browser**
   Visit URL from `minikube service ... --url` or `http://localhost:53517` and you should see the Nginx welcome page.

---

## If professor demands port 8090 specifically

Kubernetes default NodePort range disallows 8090. Two options:

* **Explain in report**: state NodePort range and show minikube-assigned port (correct answer).
* **Force minikube api-server to allow 1–65535** (not recommended in exams but possible):

```bash
minikube stop
minikube start --extra-config=apiserver.service-node-port-range=1-65535 --driver=docker
# then edit service nodePort to 8090 (kubectl edit svc nginx-service)
```

This requires admin rights and is unusual in exam environments — better to explain.

---

## Evidence to capture

* `minikube start` console output
* `kubectl get pods` and `kubectl get svc` outputs (screenshot or copy)
* `minikube service nginx-service --url` output
* Browser screenshot showing Nginx page at the service URL
* Short `kubectl describe svc nginx-service` if asked

---

# Q3 — Nagios (monitoring) inside Docker (25 marks)

Goal: run Nagios (containerized), show web UI monitoring CPU, memory, services.

## Quick & reliable method (Docker)

1. **Pull image** (test image with web UI)

```bash
docker pull jasonrivers/nagios
```

2. **Run container exposing web UI (port 80 inside container)**

```bash
docker run -d --name nagios -p 8085:80 jasonrivers/nagios
```

3. **Open UI**
   `http://localhost:8085`
   Default credentials often: `nagiosadmin` / `nagios` (check image docs).

4. **Configure monitoring of host resources**

* Many quick Docker images come preconfigured for basic checks.
* To monitor host CPU/memory you can:

  * Install NRPE on host and add NRPE checks in Nagios config (advanced), OR
  * Use Nagios Docker container to check Docker stats or set up SNMP or simple HTTP checks of endpoints.

## Commands for verification

```bash
docker ps
docker logs nagios | tail -n 50
```

## Evidence to collect

* `docker run` command (copy)
* `docker ps` output showing nagios container
* Screenshot of Nagios dashboard showing services/hosts and status
* Optional: small Nagios config snippet showing check commands

## Quick troubleshooting

* Port collision → use another local port (`-p 8086:80`).
* Container fails → `docker logs nagios` for errors.
* If you need CPU/Memory graphs, you may need to add external plugins (or use Nagios XI — commercial) — for exam, a basic service status/some checks is usually sufficient.

---

# Q4 — UML Design (Sequence Diagram and Class Diagram) (25 marks)

Goal: clear, labeled UML diagrams (Sequence diagram for ATM; Class diagram for Library system).

## A. ATM Sequence Diagram — elements & messages (what to draw)

**Lifelines (left → right):** Customer → ATM Machine → Bank Server → Cash Dispenser → Receipt Printer

**Messages (ordered):**

1. Customer → ATM: `insertCard(cardData)`
2. ATM → Bank Server: `validateCard(cardData)`
3. Bank Server → ATM: `cardValid()` (or `cardInvalid()`)
4. Customer → ATM: `enterPIN(pin)`
5. ATM → Bank Server: `authenticatePIN(cardId, pin)`
6. Bank Server → ATM: `pinValid()` / `pinInvalid()`
7. Customer → ATM: `requestWithdrawal(amount)`
8. ATM → Bank Server: `checkBalance(accountId, amount)`
9. Bank Server → ATM: `sufficientFunds(boolean)`
   10a. If sufficient: ATM → Cash Dispenser: `dispense(amount)` → Cash Dispenser → ATM: `dispenseOk()`
   10b. ATM → Bank Server: `debitAccount(amount)` → Bank Server → ATM: `updateConfirmation()`
10. ATM → Receipt Printer: `printReceipt(details)` → Receipt Printer → ATM: `receiptPrinted()`
11. ATM → Customer: `returnCard()` & `presentCash()` & `showSuccess()`

* If insufficient funds: ATM → Customer: `displayError("Insufficient funds")`

**Extras:** activation boxes on ATM & Bank Server during processing; optional notes for timeout, retries, security.

## B. Library Management Class Diagram — core classes & multiplicities

**Classes:** Book, Member, Librarian, Loan (IssueRecord), Fine (optional), Library (manager).

**Attributes / Methods (examples):**

* Book: `bookId`, `title`, `author`, `copiesAvailable` — `isAvailable()`, `updateCopies(n)`
* Member: `memberId`, `name`, `email` — `borrowBook(Book)`, `returnBook(Book)`, `calculateFine()`
* Librarian: `librarianId`, `name` — `addBook()`, `removeBook()`, `issueBook()`
* Loan: `loanId`, `issueDate`, `dueDate`, `returnDate`, `fineAmount` — `isOverdue()`
  **Relationships:**
* Member 1 --- * Loan
* Book 1 --- * Loan
* Librarian manages Book (association)
  **Multiplicity:** Show `1..*`, `0..1` where applicable.

## Tools

* StarUML for diagrams (save PNG)
* If drawn on paper (some exams require), scan and attach.

**Evidence to collect:** diagram image (PNG), brief explanation of sequence/order and multiplicities.

---

# Q1–Q4 (Set 2) — extra items explained (web project, webhook, EC2)

You asked for generic guidance for other scenarios — here’s how to approach them in the exam.

---

## Jenkins Pipeline for Web Project (Set 2)

**Extra tasks:** clone repo, configure Tomcat, deploy.

**Pipeline (Jenkinsfile) – build and deploy**

```groovy
pipeline {
  agent any
  stages {
    stage('Checkout') { steps { git 'https://github.com/USER/WEB-REPO' } }
    stage('Build') {
      steps { sh 'mvn -B -DskipTests clean package' }
    }
    stage('Deploy to Tomcat') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'tomcat-creds', usernameVariable: 'TUSER', passwordVariable: 'TPASS')]) {
          sh '''
            WAR=$(ls target/*.war | head -n1)
            curl --upload-file $WAR "http://$TUSER:$TPASS@tomcat-host:8080/manager/text/deploy?path=/myweb&update=true"
          '''
        }
      }
    }
  }
}
```

**If Tomcat is local**, use `http://localhost:8080/manager/text`. Ensure `tomcat-users.xml` has `manager-script` role for Jenkins user.

**Evidence:** pipeline console showing build & deploy; web app screenshot at `http://localhost:8080/myweb`.

---

## Webhooks to trigger builds

**Basic checklist**

1. Ensure Jenkins is reachable from GitHub:

   * If Jenkins is local, expose with `ngrok http 8080` and copy the ngrok URL.
2. GitHub → Repo → Settings → Webhooks → Add webhook:

   * Payload URL: `https://<ngrok-url>/github-webhook/`
   * Content type: `application/json`
   * Events: Push
3. Jenkins job → Configure → Build Triggers → Enable **GitHub hook trigger for GITScm polling** (or Multibranch pipeline with GitHub Branch Source plugin).
4. Push a commit → check GitHub webhook delivery log (should show 200) and Jenkins build triggered.

**Evidence:** webhook screenshot, GitHub recent deliveries, Jenkins console showing started by GitHub hook.

---

## EC2 Ubuntu + Docker deploy from GitHub

**High-level steps**

1. Launch EC2: Ubuntu AMI, t2.micro (if free tier), open SSH (22) and App port (80/8080) in security group.
2. SSH in:

```bash
ssh -i mykey.pem ubuntu@<public-ip>
```

3. Install Docker:

```bash
sudo apt update
sudo apt install -y docker.io
sudo usermod -aG docker $USER
newgrp docker
```

4. Clone repo & build image:

```bash
git clone https://github.com/USER/REPO.git
cd REPO
docker build -t myapp:latest .
docker run -d -p 80:8080 --name myapp myapp:latest
```

5. Access app at `http://<ec2-public-ip>/`

**Evidence:** EC2 instance id, public IP, `docker ps`, `curl http://localhost:8080` output on instance, browser screenshot of public IP.

---

# What to include in your **exam submission** (always)

For each task include:

1. **Objective** (one line)
2. **Commands used** (copy/paste exact commands)
3. **Console output** (copy or screenshot) — include success lines like `BUILD SUCCESS` or `deployment.apps/nginx-deploy created`
4. **Screenshots** of UIs (Jenkins pipeline view, Nginx page, Nagios dashboard, StarUML diagram)
5. **Configs** you changed (Jenkinsfile, tomcat-users.xml snippet, Kubernetes YAML if used)
6. **Short troubleshooting log** — any errors and the fix (shows you know how to debug)

---

# Quick cheat-sheet — Useful commands (one block you can copy)

```bash
# Jenkins / Git
git clone https://github.com/USER/REPO.git

# Maven build
mvn -B -DskipTests clean package
mvn test

# Minikube & kubectl
minikube start --driver=docker
kubectl create deployment nginx-deploy --image=nginx
kubectl expose deployment nginx-deploy --type=NodePort --port=80 --name=nginx-service
minikube service nginx-service --url
kubectl get pods -o wide
kubectl get svc -o wide

# Docker Nagios quick run
docker pull jasonrivers/nagios
docker run -d --name nagios -p 8085:80 jasonrivers/nagios

# EC2 / Docker (on Ubuntu)
sudo apt update
sudo apt install -y docker.io git
git clone https://github.com/USER/REPO.git
cd REPO
docker build -t myapp .
docker run -d -p 80:8080 myapp

# Jenkinsfile snippet for pipeline (mvn + archive)
# (see earlier for full declarative example)
```

---

# Final notes — exam grading-friendly tips

* Always **explain why** you did something (e.g., NodePort range, tomcat manager roles). Marks are awarded for understanding.
* Collect **screenshots of success** (BUILD SUCCESS, Nginx page, Nagios dashboard, UML PNG).
* Keep one page “evidence” PDF with commands + outputs + screenshots labeled clearly (Judge will love it).
* If your environment blocks anything (e.g. ports or SMTP), **document** the reason and the workaround you used (e.g., Minikube picked port 53517 because NodePort range is 30000–32767).
